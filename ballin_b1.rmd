STAT 545 @ UBC
Assignment B-1: Making a function
Jan 1, 0001
Total Points: 100

This assignment covers making a function in R, documenting it, and testing it.

Setup
Go to canvas to get your invitation to create a GitHub repository for this project. You can find this in the description of Assignment B-1. Name your repo as you wish – keeping in mind that you’ll be using this repo for Assignment B-2, where you’ll be bundling your work from Assignment B-1 into an R package.

Make a new Rmd file containing all of your code. Be sure to use some dialogue between code chunks.

Tidy Submission (15 points)
Follow these steps to submit your work. Be sure to familiarize yourself with the rubric for a tidy submission below, before doing these steps.

Make a README file for your repository. It should be a brief document letting a visitor know what’s in this repository (at a high level) and some key things they should know about how to use the files in the repository.
Tag a release in your GitHub repository corresponding to your submission before the deadline.
Grab the URL corresponding to your tagged release, and submit that to canvas.
Rubric:

The above steps were followed.
Your work must be reproducible from beginning to end, error-free.
Code should adopt a consistent and easy-to-read style – ideally, the tidyverse style, although we’re certainly not looking for strict adherence.
You use proper English, spelling, and grammar, and write concisely. If there’s any uncertainty in determining a grade here, the UBC MDS writing rubric will be referred to.
If there’s any further uncertainty in determining a grade for this tidy submission portion, the UBC MDS mechanics rubric will be referred to.

**Exercise 1: Make a Function (25 points)**
In this exercise, you’ll be making a function and fortifying it. The function need not be complicated. The function need not be “serious”, but shouldn’t be nonsense.

Function Ideas

Did you repeat any code for a data analysis in STAT 545A? If so, consider making a function for this action.
Consider bundling a specific group_by() %>% summarise() workflow.
Write a wrapper around an existing function.
For example, perhaps accepting a narrower range of inputs (like not allowing logical vectors), or providing a different output.
A specific example: my rqdist() function is a wrapper around quantreg::rq(), narrowing its functionality.
It’s usually better to narrow a function’s focus than to broaden, so that a function doesn’t end up doing too much.
Make a function extracting parts of an "lm" object that you can’t easily access (broom aside), or measuring the “difference” between a linear and quadratic fit.
Make a special plot that you’d want to repeat when exploring your data.
…
Guidelines

Your function should not rely on anything from your working environment.
Your function should not rely on “magic numbers” – pre-selected numbers (or options) that appear inside the function that can’t be accessed by a user of the function.
For example, maybe quantile(x, type = 1, ...) appears in your function. The choice of 1 is arbitrary – unless you’re making a function like quantile_type_1().
Input should not take a rigid form. An example that’s too rigid is a data frame that’s expected to have special types of columns.
The output is consistent – for example, always gives a list. An example of inconsistent output: sapply(1:3, seq_len) gives a list, and sapply(1:3, sqrt) gives an (atomic) vector.
Your function includes appropriate arguments. (Do you handle NA’s appropriately? Are you using the ellipsis properly? etc.)

One of the chunks of code that I that repeated frequently for the tidying process in Milestone 2 of the mini data analysis was the unnesting, grouping, and factoring of a variable. It would be great to make this a function to not have to copy, paste, and modify the whole chunk over and over if a lot of variables have nested observations.

```{r}
#' @title A Function to Unnest and Factor a Variable in a Tibble
#'
#' @description 'unnest_and_factor' takes a designated variable from a designated dataframe and helps to tidy
#' the data by making sure that if there are multiple values included in a single observation with a standardized
#' separator, these values are unnested--separated--and then factored for sorting, counting, and other grouping purposes.
#'
#' @param df The name of the stored tibble you want to work with - called 'df' for dataframe based on common stackoverflow usage
#' @param var The target variable from that tibble - called 'var' as short for variable
#' @param sep The separator string that the function should use to identify nested values; include quotations for proper usage - called 'sep' to mirror dplyr language
#'
#'@return The function will return the head of the tidied version of the tibble so that you can check whether the nested values were separated correctly before proceeding with use.
#'
#'@examples
#' unnest_and_factor(steam_games, game_details,",")
#' unnest_and_factor(apt_buildings, parking_type, ",")
#' unnest_and_factor(apt_buildings, bike_parking, " and ")
#'
#' @references
#' Syntax suggested on StackOverflow by LyzandeR
#' link: \url{https://stackoverflow.com/questions/48062213/dplyr-using-column-names-as-function-arguments}
#' More information can aso be found in the book 'Tidy Evaluation' by Lionel Henry and Hadley Wickham
#' link: \url{https://tidyeval.tidyverse.org/dplyr.html}

unnest_and_factor <- function(df,var,sep) { #where y is the variable to be un-nested and x is the dataset
    var <- enquo(var)
   unnested_factored <- df %>%
    mutate(!!var:=strsplit(as.character(!!var), sep))%>% 
    unnest(!!var) %>%
    mutate(!!var:=as.factor(!!var))
}
```


**Exercise 2: Document your Function (20 points)**
In the same code chunk where you made your function, document the function using roxygen2 tags. Be sure to include:

Title.
Function description: In 1-2 brief sentences, describe what the function does.
Document each argument with the @param tag, making sure to justify why you named the parameter as you did.
(Justification for naming is not often needed, but we want to hear your reasoning.)
What the function returns, using the @return tag.


**Exercise 3: Include examples (15 points)**
Demonstrate the usage of your function with a few examples. Use one or more new code chunks, describing what you’re doing.

Note: If you want to deliberately show an error, you can use error = TRUE in your code chunk option.


```{r}
suppressPackageStartupMessages(library(datateachr)) # <- contains the data you picked!
suppressPackageStartupMessages(library(tidyverse))
```

```{r}
unnest_and_factor(steam_games, game_details,",")
```

I was also interested in testing if and how the function would work for other datasets and not just the one that I had successfully unnested before. I took a look at the other datasets in the `datateachr` package and saw that `apt_buildings` also had a nested column in the `parking_type` column.

```{r}
unnest_and_factor(apt_buildings, parking_type, ",")
```
```{r}
unnest_and_factor(apt_buildings, parking_type, "+")
```
Another column with two pieces of information in `apt_buildings`is the `bike_parking` variable. I thought this might be a good variable to try using the function on because the separator is not a comma, but the word "and".

```{r}
unnest_and_factor(apt_buildings, bike_parking, " and ")

```

**Exercise 4: Test the Function (25 points)**
Running examples is a good way of checking by-eye whether your function is working as expected. But, having a formal “yes or no” check is useful when you move on to other parts of your analysis.

Write formal tests for your function. You should use at least three non-redundant uses of an expect_() function from the testthat package, and they should be contained in a test_that() function (or more than one). They should all pass.

Example of non-redundant inputs:

Vector with no NA’s
Vector that has NA’s
Vector of a different type (if relevant)
Vector of length 0, like numeric(0).
Example of redundant inputs:

Providing a different number (unless one of these numbers have some significance, like a limit point – just tell us if that’s the case)

```{r}
#testing that using the function and doing the specific unnesting action produce the same results
#using the `steam_games` dataset and the `languages` variable, which has NAs

steam_games %>%
    count(is.na(languages))

unnested_languages <- steam_games %>%
  mutate(languages=strsplit(as.character(languages), ",")) %>%
  unnest(languages)%>%
  mutate(languages=as.factor(languages))


function_languages <- unnest_and_factor(steam_games,languages,",")


testthat::test_that("namatch", testthat::expect_identical(unnested_languages, function_languages))
```

```{r}
#testing that using the function and doing the specific unnesting action produce the same results
#using the `apt_buildings` dataset and the `facilities_available` variable, which does not have NAs
apt_buildings %>%
count(is.na(facilities_available))

unnested_facilities <- apt_buildings %>%
  mutate(facilities_available=strsplit(as.character(facilities_available), "/")) %>%
  unnest(facilities_available)%>%
  mutate(facilities_available=as.factor(facilities_available))


function_facilities <- unnest_and_factor(apt_buildings,facilities_available,"/")


testthat::test_that("nonamatch", testthat::expect_identical(unnested_facilities, function_facilities))
```

Powered by the Academic theme for Hugo.